import pickle
import warnings
import numpy as np
import os
import hashlib
warnings.filterwarnings('ignore')

try:
    import yara
    YARA_AVAILABLE = True
except ImportError:
    YARA_AVAILABLE = False
    print("[WARN] YARA not available - install with: pip install yara-python")

try:
    import pefile
    PEFILE_AVAILABLE = True
except ImportError:
    PEFILE_AVAILABLE = False
    print("[WARN] pefile not available - install with: pip install pefile")


class MalwareDetector:
    def __init__(self, model_path='./models/torrent_malware_detector_realistic_hybrid.pkl'):
        """Load the trained ML model and YARA rules"""
        print("[ML] Loading malware detection model...")
        
        self.model = None
        self.scaler = None
        self.feature_names = ['src_bytes', 'dst_bytes', 'peer_count', 'seed_count', 'num_files']
        self.le_dict = {}
        
        try:
            with open(model_path, 'rb') as f:
                self.model_data = pickle.load(f)
            
            self.model = self.model_data['model']
            self.scaler = self.model_data['scaler']
            self.feature_names = self.model_data['feature_names']
            self.le_dict = self.model_data['le_dict']
            print(f"[OK] ML Model loaded | Precision: {self.model_data['metrics']['precision']:.4f}")
            
        except Exception as e:
            print(f"[WARN] Failed to load model ({e}). Initializing fallback model...")
            self._train_fallback_model()

        # Load YARA rules
        self.yara_rules = None
        if YARA_AVAILABLE:
            self._load_yara_rules()

    def _train_fallback_model(self):
        """Train a simple Random Forest on the fly as fallback"""
        from sklearn.ensemble import RandomForestClassifier
        from sklearn.preprocessing import StandardScaler
        
        print("[ML] Training fallback model...")
        self.model = RandomForestClassifier(n_estimators=10, max_depth=5, random_state=42)
        self.scaler = StandardScaler()
        
        # Generate synthetic data
        X = []
        y = []
        # Clean
        for _ in range(100):
            X.append([np.random.randint(1000, 100000), 0, np.random.randint(1, 50), np.random.randint(1, 20), 1])
            y.append(0)
        # Malicious
        for _ in range(100):
            X.append([np.random.randint(100000, 10000000), 1000, np.random.randint(100, 500), 0, 50])
            y.append(1)
            
        X = np.array(X)
        self.model.fit(self.scaler.fit_transform(X), y)
        print("[OK] Fallback model ready")
    
    def _load_yara_rules(self):
        """Load YARA rules for malware signatures"""
        yara_rules_path = './yara_rules/malware_rules.yar'
        
        # Create default rules if not exists
        if not os.path.exists('./yara_rules'):
            os.makedirs('./yara_rules')
        
        if not os.path.exists(yara_rules_path):
            default_rules = '''
rule SuspiciousStrings {
    meta:
        description = "Detects suspicious strings in malware"
    strings:
        $s1 = "cmd.exe" nocase
        $s2 = "powershell" nocase
        $s3 = "rundll32" nocase
        $s4 = "regsvr32" nocase
        $s5 = "wscript" nocase
        $s6 = "cscript" nocase
        $s7 = "malware" nocase
        $s8 = "trojan" nocase
        $s9 = "backdoor" nocase
    condition:
        any of ($s*)
}

rule WindowsPEExecutable {
    meta:
        description = "Detects Windows PE executables"
    strings:
        $mz = "MZ"
    condition:
        $mz at 0
}

rule SuspiciousNetworkActivity {
    meta:
        description = "Detects suspicious network patterns"
    strings:
        $ip1 = /\\d{1,3}\\.\\d{1,3}\\.\\d{1,3}\\.\\d{1,3}/ 
        $url = "http://" nocase
        $socket = "socket" nocase
    condition:
        2 of them
}
'''
            with open(yara_rules_path, 'w') as f:
                f.write(default_rules)
            print(f"[OK] Created default YARA rules at {yara_rules_path}")
        
        try:
            self.yara_rules = yara.compile(filepath=yara_rules_path)
            print("[OK] YARA rules loaded successfully")
        except Exception as e:
            print(f"[WARN] Failed to load YARA rules: {e}")
    
    def scan_with_yara(self, file_path):
        """Scan file with YARA rules"""
        if not YARA_AVAILABLE or not self.yara_rules:
            return {'yara_detections': [], 'yara_available': False}
        
        try:
            matches = self.yara_rules.match(file_path)
            detections = [{'rule': m.rule, 'tags': m.tags, 'meta': m.meta} for m in matches]
            return {
                'yara_detections': detections,
                'yara_match_count': len(detections),
                'yara_available': True
            }
        except Exception as e:
            return {'yara_detections': [], 'yara_available': False, 'error': str(e)}
    
    def analyze_pe_file(self, file_path):
        """Analyze Windows PE executable"""
        if not PEFILE_AVAILABLE:
            return {'is_pe': False, 'pe_available': False}
        
        try:
            pe = pefile.PE(file_path)
            
            # Extract PE characteristics
            analysis = {
                'is_pe': True,
                'pe_available': True,
                'machine': pe.FILE_HEADER.Machine,
                'timestamp': pe.FILE_HEADER.TimeDateStamp,
                'sections': len(pe.sections),
                'entry_point': pe.OPTIONAL_HEADER.AddressOfEntryPoint,
                'suspicious_sections': []
            }
            
            # Check for suspicious section names
            suspicious_names = ['.text', '.data', '.rsrc', 'UPX', 'packed']
            for section in pe.sections:
                section_name = section.Name.decode().strip('\x00')
                if any(name.lower() in section_name.lower() for name in suspicious_names):
                    analysis['suspicious_sections'].append(section_name)
            
            # Check for packing (entropy analysis)
            for section in pe.sections:
                entropy = section.get_entropy()
                if entropy > 7.0:  # High entropy = possibly packed/encrypted
                    analysis['high_entropy_detected'] = True
                    analysis['max_entropy'] = entropy
                    break
            
            return analysis
            
        except Exception as e:
            return {'is_pe': False, 'pe_available': False, 'error': str(e)}
    
    def extract_features(self, torrent_info):
        """Extract features matching the synthetic hybrid model"""
        # Model expects: file_size, section_count, entry_point, 
        # file_entropy_full, file_entropy_header, file_entropy_trailer,
        # entropy_variance, null_byte_ratio, printable_char_ratio, 
        # byte_freq_std, unique_bytes, download_progress, torrent_piece_count
        
        # Start with provided features
        features = {
            'file_size': torrent_info.get('file_size', 0),
            'section_count': torrent_info.get('section_count', 5),
            'entry_point': torrent_info.get('entry_point', 1000),
            'download_progress': torrent_info.get('download_progress', 1.0),
            'torrent_piece_count': torrent_info.get('torrent_piece_count', 1),
        }
        
        #Note: entropy features will be added via extra_features from piece scanning
        # Defaults for features not yet computed (will be filled by extra_features or defaulted to 0)
        features.setdefault('file_entropy_full', 0.0)
        features.setdefault('file_entropy_header', 0.0)
        features.setdefault('file_entropy_trailer', 0.0)
        features.setdefault('entropy_variance', 0.0)
        features.setdefault('null_byte_ratio', 0.0)
        features.setdefault('printable_char_ratio', 0.0)
        features.setdefault('byte_freq_std', 0.0)
        features.setdefault('unique_bytes', 0)
        
        return features
    
    def predict(self, torrent_info, file_path=None, extra_features=None):
        """
        Multi-layer malware detection:
        1. ML model (network behavior)
        2. YARA rules (signature matching)
        3. PE analysis (Windows executables)
        """
        # Layer 1: ML prediction
        features = self.extract_features(torrent_info)
        
        for col in ['protocol_type', 'service', 'flag']:
            if col in self.le_dict:
                try:
                    features[col] = self.le_dict[col].transform([features[col]])[0]
                except:
                    features[col] = 0
        
        # Merge all available features
        all_features = features.copy()
        if extra_features:
            all_features.update(extra_features)
            
        # Build feature vector safely (default to 0.0 if missing)
        # Fixes KeyError: 'blp' and similar issues with mismatched models
        feature_vector_list = []
        missing_features = []
        
        for f in self.feature_names:
            if f in all_features:
                feature_vector_list.append(all_features[f])
            else:
                feature_vector_list.append(0.0)
                if f not in self.le_dict: # Don't warn for encoded features usually
                    missing_features.append(f)
        
        if missing_features and not hasattr(self, '_warned_missing'):
            print(f"[WARN] Missing features in prediction (defaulting to 0): {missing_features[:5]}...")
            self._warned_missing = True
            
        feature_vector = np.array([feature_vector_list])
        feature_vector_scaled = self.scaler.transform(feature_vector)
        
        prediction = self.model.predict(feature_vector_scaled)[0]
        proba = self.model.predict_proba(feature_vector_scaled)[0]
        
        print(f"[PRED] Model Prediction | Features: {feature_vector[0]} | Proba: {proba}")

        ml_result = {
            'is_malicious': bool(prediction),
            'confidence': float(proba[prediction]),
            'risk_score': float(proba[1] * 100)
        }
        
        # Layer 2: YARA scanning (if file available)
        yara_result = {}
        if file_path and os.path.exists(file_path):
            yara_result = self.scan_with_yara(file_path)
        
        # Layer 3: PE analysis (if Windows executable)
        pe_result = {}
        if file_path and os.path.exists(file_path):
            pe_result = self.analyze_pe_file(file_path)
        
        # Combined verdict
        combined_risk = ml_result['risk_score']
        
        # Incorporate real piece features
        if extra_features:
            entropy = extra_features.get('entropy', 0.0)
            has_mz = extra_features.get('has_mz', False)
            
            # SMART ENTROPY PENALTY: Only penalize high entropy for executables
            # Compressed media (video/audio/archives) naturally have high entropy
            # Only executables with high entropy are suspicious (packed malware)
            
            if entropy > 6.0:
                # Only apply entropy penalty if this is an executable
                if has_mz:
                    # Executable with high entropy = packed/encrypted malware
                    # Linear scaling: (Entropy - 6.0) * 15
                    # e.g. 7.0 -> +15 risk, 8.0 -> +30 risk
                    risk_increase = (entropy - 6.0) * 15
                    combined_risk += risk_increase
                    print(f"[ML] High entropy in EXECUTABLE ({entropy:.2f}) -> Risk +{risk_increase:.1f}")
                else:
                    # Non-executable with high entropy = likely compressed media (benign)
                    # No penalty - this is expected for video/audio/compressed archives
                    print(f"[ML] High entropy detected ({entropy:.2f}) but NOT executable -> No penalty")
            elif entropy < 1.0 and entropy > 0:
                # Very low entropy (text/padding) decreases risk
                combined_risk -= 10
            
            # MZ header (executable code) increases risk moderately
            if has_mz:
                combined_risk += 20  # Reduced from 40 since we now check entropy separately
                print(f"[ML] Executable detected (MZ Header) -> Risk +20")

        if yara_result.get('yara_match_count', 0) > 0:
            combined_risk += 30  # YARA matches increase risk
        
        if pe_result.get('high_entropy_detected'):
            combined_risk += 20  # Packed executables increase risk
        
        combined_risk = min(combined_risk, 100)  # Cap at 100
        combined_risk = max(combined_risk, 0)    # Floor at 0
        
        return {
            'ml_detection': ml_result,
            'yara_detection': yara_result,
            'pe_analysis': pe_result,
            'combined_risk_score': float(combined_risk),
            'verdict': 'MALICIOUS' if combined_risk > 70 else 'SUSPICIOUS' if combined_risk > 40 else 'CLEAN'
        }
