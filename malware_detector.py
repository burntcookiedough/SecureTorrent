import pickle
import warnings
import numpy as np
import os
import hashlib
warnings.filterwarnings('ignore')

try:
    import yara
    YARA_AVAILABLE = True
except ImportError:
    YARA_AVAILABLE = False
    print("âš ï¸ YARA not available - install with: pip install yara-python")

try:
    import pefile
    PEFILE_AVAILABLE = True
except ImportError:
    PEFILE_AVAILABLE = False
    print("âš ï¸ pefile not available - install with: pip install pefile")


class MalwareDetector:
    def __init__(self, model_path='./models/malware_detector_latest.pkl'):
        """Load the trained ML model and YARA rules"""
        print("ðŸ”¬ Loading malware detection model...")
        
        self.model = None
        self.scaler = None
        self.feature_names = ['src_bytes', 'dst_bytes', 'peer_count', 'seed_count', 'num_files']
        self.le_dict = {}
        
        try:
            with open(model_path, 'rb') as f:
                self.model_data = pickle.load(f)
            
            self.model = self.model_data['model']
            self.scaler = self.model_data['scaler']
            self.feature_names = self.model_data['feature_names']
            self.le_dict = self.model_data['le_dict']
            print(f"âœ… ML Model loaded | Precision: {self.model_data['metrics']['precision']:.4f}")
            
        except Exception as e:
            print(f"âš ï¸ Failed to load model ({e}). Initializing fallback model...")
            self._train_fallback_model()

        # Load YARA rules
        self.yara_rules = None
        if YARA_AVAILABLE:
            self._load_yara_rules()

    def _train_fallback_model(self):
        """Train a simple Random Forest on the fly as fallback"""
        from sklearn.ensemble import RandomForestClassifier
        from sklearn.preprocessing import StandardScaler
        
        print("âš¡ Training fallback model...")
        self.model = RandomForestClassifier(n_estimators=10, max_depth=5, random_state=42)
        self.scaler = StandardScaler()
        
        # Generate synthetic data
        X = []
        y = []
        # Clean
        for _ in range(100):
            X.append([np.random.randint(1000, 100000), 0, np.random.randint(1, 50), np.random.randint(1, 20), 1])
            y.append(0)
        # Malicious
        for _ in range(100):
            X.append([np.random.randint(100000, 10000000), 1000, np.random.randint(100, 500), 0, 50])
            y.append(1)
            
        X = np.array(X)
        self.model.fit(self.scaler.fit_transform(X), y)
        print("âœ… Fallback model ready")
    
    def _load_yara_rules(self):
        """Load YARA rules for malware signatures"""
        yara_rules_path = './yara_rules/malware_rules.yar'
        
        # Create default rules if not exists
        if not os.path.exists('./yara_rules'):
            os.makedirs('./yara_rules')
        
        if not os.path.exists(yara_rules_path):
            default_rules = '''
rule SuspiciousStrings {
    meta:
        description = "Detects suspicious strings in malware"
    strings:
        $s1 = "cmd.exe" nocase
        $s2 = "powershell" nocase
        $s3 = "rundll32" nocase
        $s4 = "regsvr32" nocase
        $s5 = "wscript" nocase
        $s6 = "cscript" nocase
        $s7 = "malware" nocase
        $s8 = "trojan" nocase
        $s9 = "backdoor" nocase
    condition:
        any of ($s*)
}

rule WindowsPEExecutable {
    meta:
        description = "Detects Windows PE executables"
    strings:
        $mz = "MZ"
    condition:
        $mz at 0
}

rule SuspiciousNetworkActivity {
    meta:
        description = "Detects suspicious network patterns"
    strings:
        $ip1 = /\d{1,3}\.\d{1,3}\.\d{1,3}\.\d{1,3}/ 
        $url = "http://" nocase
        $socket = "socket" nocase
    condition:
        2 of them
}
'''
            with open(yara_rules_path, 'w') as f:
                f.write(default_rules)
            print(f"âœ… Created default YARA rules at {yara_rules_path}")
        
        try:
            self.yara_rules = yara.compile(filepath=yara_rules_path)
            print("âœ… YARA rules loaded successfully")
        except Exception as e:
            print(f"âš ï¸ Failed to load YARA rules: {e}")
    
    def scan_with_yara(self, file_path):
        """Scan file with YARA rules"""
        if not YARA_AVAILABLE or not self.yara_rules:
            return {'yara_detections': [], 'yara_available': False}
        
        try:
            matches = self.yara_rules.match(file_path)
            detections = [{'rule': m.rule, 'tags': m.tags, 'meta': m.meta} for m in matches]
            return {
                'yara_detections': detections,
                'yara_match_count': len(detections),
                'yara_available': True
            }
        except Exception as e:
            return {'yara_detections': [], 'yara_available': False, 'error': str(e)}
    
    def analyze_pe_file(self, file_path):
        """Analyze Windows PE executable"""
        if not PEFILE_AVAILABLE:
            return {'is_pe': False, 'pe_available': False}
        
        try:
            pe = pefile.PE(file_path)
            
            # Extract PE characteristics
            analysis = {
                'is_pe': True,
                'pe_available': True,
                'machine': pe.FILE_HEADER.Machine,
                'timestamp': pe.FILE_HEADER.TimeDateStamp,
                'sections': len(pe.sections),
                'entry_point': pe.OPTIONAL_HEADER.AddressOfEntryPoint,
                'suspicious_sections': []
            }
            
            # Check for suspicious section names
            suspicious_names = ['.text', '.data', '.rsrc', 'UPX', 'packed']
            for section in pe.sections:
                section_name = section.Name.decode().strip('\x00')
                if any(name.lower() in section_name.lower() for name in suspicious_names):
                    analysis['suspicious_sections'].append(section_name)
            
            # Check for packing (entropy analysis)
            for section in pe.sections:
                entropy = section.get_entropy()
                if entropy > 7.0:  # High entropy = possibly packed/encrypted
                    analysis['high_entropy_detected'] = True
                    analysis['max_entropy'] = entropy
                    break
            
            return analysis
            
        except Exception as e:
            return {'is_pe': False, 'pe_available': False, 'error': str(e)}
    
    def extract_features(self, torrent_info):
        """Extract features matching the retrained model"""
        # Feature names: ['src_bytes', 'dst_bytes', 'peer_count', 'seed_count', 'num_files', 'protocol_type', 'service', 'flag']
        features = {
            'src_bytes': torrent_info.get('src_bytes', 0),
            'dst_bytes': torrent_info.get('dst_bytes', 0),
            'peer_count': torrent_info.get('peer_count', 0),
            'seed_count': torrent_info.get('seed_count', 0),
            'num_files': torrent_info.get('num_files', 1),
            'protocol_type': torrent_info.get('protocol', 'tcp'),
            'service': 'other', # Default
            'flag': 'SF'        # Default
        }
        return features
    
    def predict(self, torrent_info, file_path=None):
        """
        Multi-layer malware detection:
        1. ML model (network behavior)
        2. YARA rules (signature matching)
        3. PE analysis (Windows executables)
        """
        # Layer 1: ML prediction
        features = self.extract_features(torrent_info)
        
        for col in ['protocol_type', 'service', 'flag']:
            if col in self.le_dict:
                try:
                    features[col] = self.le_dict[col].transform([features[col]])[0]
                except:
                    features[col] = 0
        
        feature_vector = np.array([[features[f] for f in self.feature_names]])
        feature_vector_scaled = self.scaler.transform(feature_vector)
        
        prediction = self.model.predict(feature_vector_scaled)[0]
        proba = self.model.predict_proba(feature_vector_scaled)[0]
        
        print(f"ðŸ”® Model Prediction | Features: {feature_vector[0]} | Proba: {proba}")

        ml_result = {
            'is_malicious': bool(prediction),
            'confidence': float(proba[prediction]),
            'risk_score': float(proba[1] * 100)
        }
        
        # Layer 2: YARA scanning (if file available)
        yara_result = {}
        if file_path and os.path.exists(file_path):
            yara_result = self.scan_with_yara(file_path)
        
        # Layer 3: PE analysis (if Windows executable)
        pe_result = {}
        if file_path and os.path.exists(file_path):
            pe_result = self.analyze_pe_file(file_path)
        
        # Combined verdict
        combined_risk = ml_result['risk_score']
        
        if yara_result.get('yara_match_count', 0) > 0:
            combined_risk += 30  # YARA matches increase risk
        
        if pe_result.get('high_entropy_detected'):
            combined_risk += 20  # Packed executables increase risk
        
        combined_risk = min(combined_risk, 100)  # Cap at 100
        
        return {
            'ml_detection': ml_result,
            'yara_detection': yara_result,
            'pe_analysis': pe_result,
            'combined_risk_score': float(combined_risk),
            'verdict': 'MALICIOUS' if combined_risk > 70 else 'SUSPICIOUS' if combined_risk > 40 else 'CLEAN'
        }
